---
title: "Low dimensional visualizations"
format:
  html:
    number-sections: true
    embed-resources: true
execute:
  kernel: dataviz
  echo: true
  fig-height: 3
  fig-width: 4

---

# Low dimensional visualizations

```{python}
#| include: false
import pandas as pd
import numpy as np
from plotnine import *
import matplotlib.pyplot as plt
from IPython.display import display, Image
import matplotlib

# Plot theme similar to the original R `mytheme`
mysize = 9
mytheme = theme(
    axis_title = element_text(size=mysize), 
    axis_text = element_text(size=mysize),
    legend_title = element_text(size=mysize),
    legend_text = element_text(size=mysize),
    ) + theme_minimal(base_size=mysize)

np.random.seed(0)

```

## Why plotting?

Plotting is crucial to data science because:

- It facilitates making new observations by discovering associations or patterns in the data (the initial step of the scientific method ^[https://en.wikipedia.org/wiki/Scientific_method]). The human brain is particularly good at detecting patterns in images, which is what we evolved for. Visual display, over staring at tables of numbers, is very effective.

- It facilitates communicating findings.

- Only relying on summary statistics (mean, correlation, etc.) is dangerous. Summary statistics reduce data to a single number, therefore carry much less information than 2D representations. @sec-plot-vs-stat provides examples.

- It helps debugging either the code by visually checking whether particular operations performed as expected on the data, or by identifying "bugs in the data" such as wrong entries or outliers. @sec-plot-debug provides an example.

### Plotting versus summary statistics {#sec-plot-vs-stat}
What do those 13 datasets have in common?

![](../../assets/img/missleading-data-1.png){width=600}

![](../../assets/img/missleading-data-2.png){width=300}

All those plots, including the infamous datasaurus share the same following statistics:

- X mean: 52.26
- Y mean: 47.83
- X standard deviation: 16.76
- Y standard deviation: 29.93
- Pearson correlation: -0.06

When only looking at the statistics, we would have probably wrongly assumed that the datasets were identical. This example highlights why it is important to visualize data and not just rely on summary statistics. See https://github.com/lockedata/datasauRus or Anscombe's quartet https://en.wikipedia.org/wiki/Anscombe%27s_quartet for more examples.

### Plotting helps finding bugs in the data {#sec-plot-debug}
Consider the following vector `height` containing (hypothetical) height measurements for 500 adults:

```{python}
#| echo: false
np.random.seed(0)
height_df = pd.DataFrame({'height': np.round(np.append(np.random.normal(1.73, 0.045, 499), 165), 2)})
```

```{python}
height_df.head()
```

Calculating the mean height returns the following output:

```{python}
height_df['height'].mean()
```

There is something obviously wrong. We can plot the data to investigate.

```{python}
#| fig-align: "center"
(ggplot(height_df, aes('height')) + geom_histogram(bins=50) + mytheme)
```

There is an outlier (height=165). One particular value has probably been entered in centimeters rather than meters. As a result, the mean is inflated.

A quick way to fix our dataset is to remove the outlier, for instance with:

```{python}
height_df = height_df[height_df['height'] < 3]
```

Now our plotted data seems more realistic and the mean height makes sense.

```{python}
height_df['height'].mean()
```
```{python}
#| fig-align: "center"
(ggplot(height_df, aes('height')) + geom_histogram() + mytheme)
```

While developing analysis scripts, we recommend to frequently visualize the data to make sure no mistake in the input or during the processing occurred.

## Grammar of graphics

The grammar of graphics is a visualization theory developed by Leland Wilkinson in 1999. It has influenced the development of graphics and visualization libraries alike. It is based on 3 key principles:

- Separation of data from aesthetics (e.g. x and y-axis, color-coding)
- Definition of common plot/chart elements (e.g. scatter plots, box-plots, etc.)
- Composition of these common elements (one can combine elements as layers)

The library `plotnine` is a Python implementation inspired by ggplot2 and follows the grammar of graphics closely.

Here is a sophisticated motivating example. The plot shows the relationship between per-capita gross domestic product (GDP) and life expectancy at birth for the years 1977 and 2007 from the dataset `gapminder`:

```{python}
#| label: fig-gapminder-motivation
#| fig-align: "center"
gapminder = pd.read_csv("https://raw.github.com/jennybc/gapminder/refs/heads/main/inst/extdata/gapminder.tsv", sep="\t")
gm_df = gapminder[gapminder['year'].isin([1977, 2007])]
(
    ggplot(gm_df, aes(x='gdpPercap', y='lifeExp', color='continent', size='pop'))
    + geom_point()
    + scale_x_log10()
    + facet_grid('~year')
    + labs(x='per-capita GDP', y='Life expectancy at birth', size = 'Population')
    + mytheme  + theme(figure_size=(6,3))
)
```

We may, for instance, use such visualization to find differences in the life expectancy of each country and each continent.

The following section shows how to create such a sophisticated plot step by step.

### Components of the layered grammar

Grammar of graphics composes plots by combining layers. The major layers are:

- Always used:

  Data: a `pandas.DataFrame` where columns correspond to variables

  Aesthetics: mapping of data to visual characteristics - what we will see on the plot (`aes`) — position (x,y), color, size, shape, transparency

  Geometric objects: geometric representation defining the type of the plot data (`geom_`) — points, lines, boxplots, ...

- Often used:

  Scales: for each aesthetic, describes how a visual characteristic is converted to display values (`scale_`) — log scales, color scales, size scales, ...

  Facets: describes how data is split into subsets and displayed as multiple sub graphs (`facet_`)

- Useful, but with care:

  Stats: statistical transformations that typically summarize data (`stat`) — counts, means, medians, regression lines, ...

- Domain-specific usage:

  Coordinate system: describes 2D space that data is projected onto (`coord_`) — Cartesian coordinates, polar coordinates, map projections, ...

### Defining the data and layers

To demonstrate the application of grammar of graphics, we will build step by step the gapminder figure @fig-gapminder-motivation. First, we have a look at the first lines of the dataset:

```{python}
gm_df[['country','continent','gdpPercap','lifeExp','year']].head()
```

For starting with the visualization we initiate a `ggplot` object which generates a plot with background:

```{python}
#| fig-align: "center"
(ggplot(gm_df))
```

Next, we can define the data to be plotted, which needs to be a `pandas.DataFrame` and the `aes()` function. This `aes()` function defines which columns map to `x` and `y` coordinates and if they should be colored or have different shapes and sizes based on the values in a different column. These elements are called "aesthetic" elements.

```{python}
#| fig-align: "center"
(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp')))
```

We want to visualize the data with a simple scatter plot. In a scatter plot, the values of two variables are plotted along two axes. Each pair of values is represented as a point. We combine the function `geom_point()` to create a scatter plot:

```{python}
#| fig-align: "center"
(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp'))
  + geom_point())
```

One of the advantages of plotting with grammar-of-graphics libraries is that the plot object can be stored and modified. For example:

```{python}
p = ggplot(gm_df, aes(x='gdpPercap', y='lifeExp')) + geom_point()
print(type(p))
```

### Mapping of aesthetics

#### Mapping of color, shape and size

We can easily map variables to different colors, sizes or shapes depending on the value of the specified variable. To assign each point to its corresponding continent, we can define the variable `continent` as the `color` attribute in `aes()`:

```{python}
#| fig-align: "center"
(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp', color='continent')) + geom_point())
```

Instead of color, we can also use different shapes for characterizing categories (note: some backends limit number of shapes):

```{python}
#| fig-align: "center"
(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp', shape='continent')) + geom_point())
```

Additionally, we distinguish the population of each country by giving a size to the points in the scatter plot:

```{python}
#| fig-align: "center"
(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp', color='continent', size='pop')) + geom_point())
```

#### Global versus individual mapping

Mapping of aesthetics in `aes()` can be done globally or at individual layers. Global mapping is inherited by default to all geom layers, while mapping at individual layers is only recognized at that layer. Example:

```{python}
#| fig-align: "center"
(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp')) + geom_point(aes(color='continent', size='pop')))
```

### Facets, axes and labels

For comparing the data from different years, we can add a facet with `facet_wrap()`:

```{python}
#| fig-align: "center"
(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp', color='continent', size='pop'))
   + geom_point() 
   + facet_wrap('~year')
   + theme(figure_size=(6,3)))
```

For a better visualization of the data points, we can consider log scaling (detailed in section @sec-log-scaling). Finally, we can adapt the axes labels of the plot with `labs()` and define a theme of our plot:

```{python}
#| fig-align: "center"
mysize = 9
mytheme = theme(
    axis_title = element_text(size=mysize), 
    axis_text = element_text(size=mysize),
    legend_title = element_text(size=mysize),
    legend_text = element_text(size=mysize),
    ) + theme_minimal(base_size=mysize)

(ggplot(gm_df, aes(x='gdpPercap', y='lifeExp'))
    + geom_point(aes(color='continent', size='pop'))
    + facet_grid('~year')
    + scale_x_log10()
    + labs(x='Per-capita GDP', y='Life expectancy at birth', size='Population')
    + mytheme + theme(figure_size=(6,3)))
```

## Different types of one- and two-dimensional plots

In the previous examples, we had a look at scatter plots which are suitable for plotting the relationship between two continuous variables. However, there are many more types of plots (e.g. histograms, boxplots) which can be used for plotting in different scenarios. Mainly, we distinguish between plotting one or two variables and whether the variables are continuous or discrete.

### Plots for one single continuous variable

#### Histograms

A histogram represents the frequencies of values of a variable bucketed into ranges or bins. It takes as input numeric variables only. The height of a bar for a given range in a histogram represents the number of values present in that bin. 

We will make use of a dataset collecting Human Development Index (HDI from http://hdr.undp.org/) and Corruption Perception Index (CPI from http://www.transparency.org/) of various countries. We first load these data into a new data table `ind` and have a first look at the table:

```{python}
ind = pd.read_csv('../../extdata/CPI_HDI.csv').drop(columns=['Unnamed: 0'])
ind.head()
```

```{python}
#| fig-align: "center"
(ggplot(ind, aes('HDI')) + geom_histogram() + mytheme)
```

We can change the number of desired bins ^[There does not seem to be any widely accepted heuristics to choose the number of bins of a histogram based on data. We recommend trying different values if the default seems to be suboptimal.] in the `bins` argument of the `geom_histogram()` function:

```{python}
#| fig-align: "center"
(ggplot(ind, aes('HDI')) + geom_histogram(bins=10) + mytheme)
```

#### Density plots

In some situations, histograms are not the best choice to investigate the distribution of a variable due to discretization effects during the binning process. A variation of histograms is given by density plots. They are used to represent the distribution of a numeric variable. These distribution plots are typically obtained by kernel density estimation to smoothen out the noise. Thus, the plots are smooth across bins and are not affected by the number of bins, which helps create a more defined distribution shape.

As an example, we can visualize the distribution of the Human Development Index (HDI) in the `ind` dataset by means of a density plot with `geom_density()`:

```{python}
#| fig-align: "center"
(ggplot(ind, aes('HDI')) + geom_density() + mytheme)
```

The `bw` argument of the `geom_density()` function allows to tweak the bandwidth of a density plot manually. The default option is a bandwidth rule, which is usually a good choice.

Setting a small bandwidth on the previous plot has a huge impact on the plot:

```{python}
#| fig-align: "center"
(ggplot(ind, aes('HDI')) + geom_density(bw=0.01) + ggtitle('Small bandwidth') + mytheme)
```

Setting a large bandwidth has also a huge impact on the plot:

```{python}
#| fig-align: "center"
(ggplot(ind, aes('HDI')) + geom_density(bw=1) + ggtitle('Large bandwidth') + mytheme)
```

Thus, we should be careful when changing the bandwidth, since we can get a wrong impression from the distribution of a continuous variable.

#### Boxplots

Boxplots can give a good graphical insight into the distribution of the data. They show the median, quartiles, and how far the extreme values are from most of the data.

Four values are essential for constructing a boxplot:

* the median
* the first quartile (Q1)
* the third quartile (Q3)
* the interquartile range (IQR): the difference between Q3 and Q1

See http://web.pdx.edu/~stipakb/download/PA551/boxplot.html for a good illustration. 

Every boxplot has lines at Q1, the median, and Q3, which together build the box of the boxplot. The other major feature of a boxplot is its whiskers. The whiskers are determined with the help of the IQR. Data points outside of 1.5 x IQR is called an outlier. We then draw lines at the smallest and largest point within this subset (Q1 - 1.5 × IQR to Q3 + 1.5 × IQR) from the dataset. These lines define our whiskers which reach the most extreme data point within $\pm  1.5\times IQR$.

It is possible to not show the outliers in boxplots. However, we strongly recommend keeping them. Outliers can reveal interesting data points (discoveries "out of the box") or bugs in data preprocessing.

For instance, we can plot the distribution of a variable `x` with a histogram and visualize the corresponding boxplot:

```{python}
#| echo: false
#| fig-align: "center"
xl = [0, 5]
dt = pd.DataFrame({'x': np.random.lognormal(mean=0, sigma=0.5, size=1000)})
dt['group'] = 'x'

(ggplot(dt, aes('x')) + geom_histogram(bins=30) + mytheme)
```
```{python}
#| echo: false
#| fig-align: "center"
(ggplot(dt, aes('group', 'x')) + geom_boxplot() + coord_flip() + mytheme)
```

Boxplots are particularly suited for plotting non-Gaussian symmetric and non-symmetric data and for plotting exponentially distributed data. However, boxplots are not well suited for bimodal data, since they only show one mode (the median). In the following example, we see a bimodal distribution in the histogram and the corresponding boxplot, which does not properly represent the distribution of the data.

```{python}
#| echo: false
#| fig-align: "center"
dt = pd.DataFrame({
    'x': 1,
    'y': np.append(np.random.normal(loc=-3, size=100),np.random.normal(loc=3, size=100))
})
(ggplot(dt, aes(x='x', y='y'))
  + geom_boxplot()
  + mytheme)
```
```{python}
#| echo: false
#| fig-align: "center"
(ggplot(dt, aes(x='y'))
  + geom_histogram()
  + mytheme)
```

Boxplots are also not suited for categorical data and discrete data with very few values, for which bar plots are preferred (@sec-barplots).

### Plots for two variables: one continuous, one discrete

#### Barplots {#sec-barplots}

Barplots are often used to highlight individual quantitative values per category. Bars are visual heavyweights compared to dots and lines. In a barplot, we can combine two attributes of 2-D location and line length to encode quantitative values. In this manner, we can focus the attention primarily on individual values and support the comparison of one to another.

For creating a barplot with `plotnine` we can use the function `geom_bar()`. In the next example, we visualize the number of countries (defined in the `y` axis) per continent (defined in the `x` axis).

```{python}
#| fig-align: "center"
countries_dt = pd.DataFrame({
    'Continent': ["North America", "South America", "Africa", "Asia", "Europe", "Oceania"],
    'Number_countries': [23, 12, 54, 49, 50, 16]
})

(ggplot(countries_dt, aes('Continent', 'Number_countries')) + geom_bar(stat='identity', width=0.7)
    + mytheme + theme(figure_size=(6,3)))
```

#### Barplots with errorbars

Visualizing uncertainty is important, otherwise, barplots with bars as a result of an aggregation can be misleading. One way to visualize uncertainty is with error bars.

As error bars, we can consider the standard deviation (SD) and the standard error of the mean (SEM). SD and SEM are related yet different concepts. On the one hand, SD indicates the variation of quantity in the sample. On the other hand, SEM represents how well the mean is estimated.

The central limit theorem implies that $SEM = SD / \sqrt{n}$ , where $n$ is the sample size, i.e. the number of observations. With large $n$, SEM tends to 0, i.e. our uncertainty about the distibution's expected value decreases with larger samples sizes. In contrast, SD converges with large sample size to the distribution's standard deviation.  

In the following example (Figure @fig-hwy-sd), we plot the average highway miles per gallon `hwy` per vehicle class `class` including error bars computed as the average plus/minus standard deviation of `hwy`. Because of the various possibilities of error bars used in the literature, it is recommended to always specify in the legend of a figure what the error bars represent.

```{python}
#| fig-cap: "Mean +/- standard deviation of highway miles per gallon per car class."
#| label: fig-hwy-sd
#| fig-align: "center"
from plotnine.data import mpg
mpg_df = mpg.copy()
summary = mpg_df.groupby('class').agg(mean_hwy=('hwy', 'mean'), sd_hwy=('hwy', 'std')).reset_index()
summary['ymax'] = summary['mean_hwy'] + summary['sd_hwy']
summary['ymin'] = summary['mean_hwy'] - summary['sd_hwy']

(ggplot(summary, aes('class', 'mean_hwy', ymax='ymax', ymin='ymin'))
    + geom_bar(stat='identity')
    + geom_errorbar(width=0.3)
    + mytheme + theme(figure_size=(6,3)))
```

#### Boxplots by category

As illustrated before, boxplots are well suited for plotting one continuous variable. However, we can also use boxplots to show distributions of continuous variables with respect to some categories. This can be particularly interesting for comparing the different distributions of each category.

For instance, we want to visualize the highway miles per gallon `hwy` for every	one of the 7 vehicle classes	(compact, SUV, minivan, etc.). For this, we define the categorical `class` variable on the `x` axis and the continuous variable `hwy` on the `y` axis.

```{python}
#| fig-align: "center"
(ggplot(mpg_df, aes('class', 'hwy')) + geom_boxplot() + mytheme + theme(figure_size=(6,3)))
```

One can also use `geom_jitter()`, which arbitrarily adds some randomness to the x-position of the data points within each box in order to separate them visually.

```{python}
#| fig-align: "center"
p = ggplot(mpg_df, aes('class', 'hwy')) + geom_boxplot() + mytheme + theme(figure_size=(6,3))
(p + geom_jitter(width=0.2))
```

#### Violin plots

A violin plot is an alternative to the boxplot for visualizing one continuous variable (grouped by categories). An advantage of the violin plot over the boxplot is that it also shows the entire distribution of the data. This can be particularly interesting when dealing with multimodal data.

For a direct comparison, we show a violin plot for the `hwy` grouped by `class` as before with the help of the function `geom_violin()`:

```{python}
#| fig-align: "center"
(ggplot(mpg_df, aes('class', 'hwy')) + geom_violin() + mytheme + theme(figure_size=(6,3)))
```

### Plots for two continuous variables

#### Scatter plots

Scatter plots are a useful plot type for easily visualizing the relationship between two continuous variables. Here, dots are used to represent pairs of values corresponding to the two considered variables. The position of each dot on the horizontal (`x`) and vertical (`y`) axis indicates values for an individual data point.

In the next example, we analyze the relationship between the engine displacement in liters `displ` and the highway miles per gallon `hwy` from the `mpg` dataset:

```{python}
#| fig-align: "center"
(ggplot(mpg_df, aes('displ', 'hwy')) + geom_point() + mytheme)
```

We can modify the previous plot by coloring the points depending on the vehicle class:

```{python}
#| fig-align: "center"
(ggplot(mpg_df, aes('displ', 'hwy', color='class')) + geom_point() + mytheme)
```

Sometimes, too many colors can be hard to distinguish. In such cases, we can use `facet` to separate them into different plots:

```{python}
#| fig-align: "center"
(ggplot(mpg_df, aes('displ', 'hwy')) + geom_point() + facet_wrap('~class')
   + mytheme + theme(figure_size=(6,4)))
```

##### Text labeling

For labeling the individual points in a scatter plot, `plotnine` offers the function `geom_text()`. However, these labels tend to overlap. To avoid this, we can use the library `ggrepel` which offers a better text labeling through the function `geom_text_repel()`.

We first show the output of the classic text labeling with `geom_text()` for a random subset of 40 observations of the dataset `mpg`. Here we plot the engine displacement in liters `displ` vs. the highway miles per gallon `hwy` and label by `manufacturer`:

```{python}
#| fig-align: "center"
mpg_subset = mpg_df.sample(n=30, random_state=12)
(ggplot(mpg_subset, aes('displ', 'hwy', label='manufacturer')) + geom_point() + geom_text() + mytheme)
```

##### Log scaling {#sec-log-scaling}

We consider another example where we want to plot the weights of the brain and body of different animals using the dataset `Animals`. This is what we obtain after creating a scatterplot.

```{python}
#| fig-align: "center"
animals_df = pd.read_csv("https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/MASS/Animals.csv")
(ggplot(animals_df, aes('body', 'brain')) + geom_point() + mytheme)
```

We can clearly see that there are a few points which are notably larger than most of the points. This makes it harder to interpret the relationships between most of these points. In such cases, we can consider **logarithmic** transformations and/or scaling. More precisely, a first idea would be to manually transform the values into a logarithmic space and plot the transformed values instead of the original values:

```{python}
#| fig-align: "center"
animals_df["log_body"] = np.log10(animals_df["body"])
animals_df["log_brain"] = np.log10(animals_df["brain"])
(ggplot(animals_df, aes('log_body', 'log_brain')) + geom_point() + mytheme)
```

Alternatively, `plotnine` offers to simply scale the data without the need to transform. This can be done with the help of the functions `scale_x_log10()` and `scale_y_log10()` which allow appropriate scaling and labeling of the axes:

```{python}
#| fig-align: "center"
(ggplot(animals_df, aes('body', 'brain')) + geom_point() + scale_x_log10() + scale_y_log10() + mytheme)
```

## 2D-Density plots

Using scatterplots can become problematic when dealing with a huge number of points. This is due to the fact that points may overlap and we cannot clearly see how many points are at a certain position. In such cases, a 2D density plot is particularly well suited. This plot counts the number of observations within a particular area of the 2D space.

The function `geom_bin_2d()` is creates 2D density plots in python:

```{python}
#| fig-align: "center"
x = np.random.randn(10000)
y = x + np.random.randn(10000)
df = pd.DataFrame({'x': x, 'y': y})
(ggplot(df, aes('x', 'y')) + geom_bin_2d() + mytheme)
```

#### Line plots

A line plot can be considered for connecting a series of individual data points or to display the trend of a series of data points.
This can be particularly useful to show the shape of data as it flows and changes from point to point. We can also show the strength of the movement of values up and down through time.

As an example we show the connection between the individual datapoints of unemployment rate over the years:

```{python}
#| echo: false
economics = pd.read_csv("https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/ggplot2/economics.csv")
economics['date'] = pd.to_datetime(economics['date'])
economics['unemploy_pop_ratio'] = economics['unemploy'] / economics['pop']
```

```{python}
#| fig-align: "center"
(ggplot(economics, aes(x='date', y='unemploy_pop_ratio'))
  + geom_line()
  + mytheme)
```

## Further plots for low dimensional data

### Plot matrix

A plot matrix is useful for exploring the distributions and correlations of a few variables in a matrix-like representation. Here, for each pair of considered variables, a scatterplot is shown. Moreover, a density plot is created for every single variable (diagonal).

We can use the function `sns.pairplot()` from the library `seaborn` for constructing plot matrices:

```{python}
#| fig-align: "center"
import seaborn as sns
mpg = sns.load_dataset('mpg')
columns_to_plot = ['displacement', 'cylinders', 'mpg', 'horsepower']
sns.pairplot(mpg, vars=columns_to_plot, kind='scatter', diag_kind='kde', aspect=2, size=1)
```

This plot is recommended and suited for a handful of variables but does not scale up to much more variables.

## Summary

This chapter covered the basics of the grammar of graphics and `plotnine` to plot low dimensional data. We introduced the different types of plots such as histograms, boxplots or barplots and discussed when to use which plot.

## Resources

* The ggplot book: https://ggplot2-book.org/
* The plotnine guide: https://plotnine.org/reference/

* Udacity's Data Visualization and D3.js
  * https://www.udacity.com/courses/all

* Graphics principles
  * https://onlinelibrary.wiley.com/doi/full/10.1002/pst.1912
  * https://graphicsprinciples.github.io/
