---
title: "High dimensional visualizations"
format:
  html:
    number-sections: true
    embed-resources: true
execute:
  kernel: dataviz
  echo: true
  fig-height: 3
  fig-width: 4
  warning: false
---

```{python}
#| include: false
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from plotnine import *
import sklearn
from scipy.cluster.hierarchy import linkage, dendrogram, fcluster

# Set theme similar to original
mysize = 9
mytheme = (theme_bw() +
           theme(axis_title=element_text(size=mysize),
                 axis_text=element_text(size=mysize),
                 legend_title=element_text(size=mysize),
                 legend_text=element_text(size=mysize)))

np.random.seed(0)
```

In this chapter, we turn our attention to the visualization of high-dimensional data with the aim to discover interesting patterns. We cover heatmaps, i.e., image representation of data matrices, and useful re-ordering of their rows and columns via clustering methods. To scale up visualization to very high-dimensional data, we furthermore introduce Principal Component Analysis as a dimension reduction technique.

## Notations
Lower cases are used for scalars (e.g. $x$), bold lower cases for vectors (e.g. $\mathbf{x}$) and bold upper cases for matrices (e.g. $\mathbf{X}$). The transpose of a matrix or of a vector is denoted with a T-superscript (e.g. $\mathbf{X}^\top$). The Euclidean norm of vector $\mathbf{x}$ is denoted $||\mathbf{x}||$.

Methods of this chapter assume numeric variables. If encountered, categorical variables can be transformed to numeric variables by one-hot encoding ^[https://deepai.org/machine-learning-glossary-and-terms/one-hot-encoding].

We denote $n$ the number of observations, $p$ the number of variables, and $\mathbf{X}$ the $n \times p$ data matrix.

## Data matrix preparation
We use a subset of the base R `mtcars` dataset consisting of 10 rows (cars) and four selected variables. We store this data into the numeric matrix `mat`. For ease, we give full names (rather than abbreviations) to the columns and keep the row names (car names).

```{python}
from plotnine.data import mtcars
mat = mtcars.iloc[1:10][["mpg", "carb", "hp", "wt"]].copy()
mat.index = mtcars.name[1:10]
mat.columns = ["Miles.per.gallon", "Carburetor", "Horsepower", "Weight"]
mat.head()
```

## Heatmaps
Beyond 5 to 10 variables, matrix scatterplots cannot be rendered with enough resolution to be useful. However, **heatmaps** which simply display data matrices as an image by color-coding its entries, become handy. Heatmaps allow visualization of data matrices of up to ca. 1,000 rows and columns (order of magnitude), i.e the pixel resolution of your screen (and maybe of your eyes!).  

To draw heatmaps, we recommend using the library `sns.clustermap` (pretty heatmaps), which offers convenient functionalities in particular for clustering (See @sec-hclust).

Here is a basic call to `sns.clustermap` on our data matrix `mat`:

```{python}
#| fig-align: center
import seaborn as sns
g = sns.clustermap(mat, row_cluster=False, col_cluster=False, figsize=(4,4))
```

Strikingly, the horsepower variable saturates the color scale because horsepower lives in  a different scale than the other variables. Consequently, we barely see variations in the other variables.    

### Centering and scaling variables
Bringing variables to a common scale is useful for visualization but also for computational and numerical reasons. Moreover, it makes analysis independent of the units chosen. For instance the `mtcars` dataset provide car weights in 1,000 pounds and gas consumption in miles per gallon. We would certainly want our analysis to be the same if these variables were expressed with the metric system.

The widely used operations to bring variables to a same scale are:

* **centering**: subtracting the mean

* **standard scaling** or **Z-score normalization**: centering then dividing by the standard deviation

These operations are implemented in the base scikit-learn function `StandardScaler()` and are often offered as parameters of other functions. Scaling is usually done for variables (data matrix columns). However, in some application contexts, row-scaling can be considered as well.  

With `sns.clustermap` we can also scale the data by rows or columns by setting the argument `z_score` accordingly. We do it here in the classical way, by column:

```{python}
#| fig-align: center
#| label: fig-scaled_heatmap
#| fig-cap: Scaled heatmap.
sns.clustermap(mat, row_cluster=False, col_cluster=False, z_score=1, figsize=(4,4))
```

Scaling allows us to appreciate the variation for all variables. The default color scale is centered on 0. Because each column is centered, we find positive (red-ish) and negative (blue-ish) values in each column. 

## Clustering

While all data are rendered in the @fig-scaled_heatmap, it is hard to see a pattern emerging. Which cars are similar to each others? Which variables are similar to each other? Clustering is the task of grouping observations by similarities. Clustering helps finding patterns in data matrices. Clustering can also be applied to variables, by simply applying clustering methods on the transpose of the data matrix. 

There are several clustering algorithms. In the following sections, we explain two widely used clustering methods: K-means clustering and hierarchical clustering. 


### K-Means clustering
#### Objective

K-Means clustering aims to partition the observations into $K$ non-overlapping clusters. The number of clusters $K$ is predefined. The clusters $C_1,...C_K$ define a partition of the observations, i.e., every observation belongs to one and only one cluster. To this end, one makes use of so-called cluster centroids, denoted $\boldsymbol{\mu_1}, ..., \boldsymbol{\mu_K}$, and associates each observation to its closest centroid (@fig-kmeansaim). 

```{python}
#| echo: false
#| label: fig-kmeansaim
#| fig-align: center
#| fig-cap: "K-means clustering partitions observations into K clusters (here K=3) by associating each observation to its closest centroids (crosses)."
from sklearn.datasets import make_blobs

# Reproducibility
random_state = 0

# Parameters
K = 3
nk = 8
centers = np.array([
    [0, 0],
    [-5, 5],
    [7, 3]
])

# Generate data (isotropic Gaussian with std=1 -> covariance = I)
X, y = make_blobs(
    n_samples=[nk] * K,
    centers=centers,
    cluster_std=1.0,
    random_state=random_state
)

# Build data frames
dt = pd.DataFrame({
    'Cluster': [f'C{i+1}' for i in y],
    'x': X[:, 0],
    'y': X[:, 1]
})

mu_dt = pd.DataFrame({
    'Cluster': [f'C{i+1}' for i in range(K)],
    'x': centers[:, 0],
    'y': centers[:, 1],
    'label': [f'mu[{i+1}]' for i in range(K)]
})

# Plot
(ggplot(dt, aes(x='x', y='y', color='Cluster')) +
    geom_point() +
    mytheme +
    geom_point(mu_dt, aes(x='x', y='y', color='Cluster'),
               shape='x', size=3, show_legend=False))
```

Formally, one aims to determine the clusters $C_1,...,C_K$ and the centroids $\boldsymbol{\mu_1},...,\boldsymbol{\mu_K}$ in order to minimize the within-cluster sum of squares:

$$
\min_{C_1,...,C_K, \boldsymbol{\mu_1},...,\boldsymbol{\mu_k}} \sum_{k=1}^K\sum_{i \in C_k}|| \mathbf{x_i} -  \boldsymbol{\mu_k}||^2
$$ {#eq-kmeansobj}

where $||\mathbf{x_i} -  \boldsymbol{\mu_k}||^2 = \sum_{j=1}^p(x_{i,j} - \mu_{k,j})^2$ is the squared Euclidean distance between observation $\mathbf{x_i}$ (the $i$-th row vector of the data matrix) and the centroid  $\boldsymbol{\mu_k}$. 


#### Algorithm 
The minimization problem (@eq-kmeansobj) is difficult because of the combinatorial number of partitions of $n$ observations into $K$ clusters. However, two useful observations can be made.

First, if we assume that the positions of the centroids \bs\mu_k are given, then each summand $|| \mathbf{x_i} -  \boldsymbol{\mu_k}||^2$ in @eq-kmeansobj can be minimized by including the observation $\mathbf{x_i}$ to the cluster of its closest centroid. The number of clusters $K$ depends on the dataset.

Second, if we now assume that the clusters are given, then the values of the centroids that minimize $\sum_{i \in C_k}|| \mathbf{x_i} -  \boldsymbol{\mu_k}||^2$ are the observation means, i.e. $\boldsymbol{\mu_k} = \frac{1}{|C_k|}\sum_{i \in C_k} \mathbf{x_i}$. Hence, the centroids are the cluster means, giving the name of the algorithm.  

These two observations lead to an iterative algorithm that provides in practice good solutions, even though it does not guarantee to find the optimal solution.

![K-mean algorithm. Source: https://en.wikipedia.org/wiki/K-means_clustering](../../assets/img/kMeansD.png){#fig-kmeans_algo fig-align="center" fig-width=300}

**K-Means algorithm** (@fig-kmeans_algo)

1. Choose the $K$ initial centroids (one for each cluster). Different methods such as sampling random observations are available for this task.

2. Assign each observation $\mathbf{x_i}$ to its nearest centroid by computing the Euclidean distance between each observation to each centroid. 

3. Update the centroids $\boldsymbol{\mu_k}$ by taking the mean value of all of the observations assigned to each previous centroid.

4. Repeat steps 2 and 3 until the difference between new and former centroids is less than a previously defined threshold.


At every iteration, and at every step 2 and 3, the within-cluster sum of squares (@eq-kmeansobj) decreases. 

However, there is no guarantee to reach the optimal solution. In particular, the final clustering depends on the initialization (step 1). To not overly depend on the initialization, the K-means algorithm is typically executed with different random initializations. The clustering with lowest within-cluster sum of squares is then retained.

#### Considerations and drawbacks of K-Means clustering

We have to make sure that the following assumptions are met when performing k-Means clustering (@fig-kmeans_fail, Source: scikit-learn ^[https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_assumptions.html]):

* The number of clusters $K$ is properly selected
* The clusters are isotropically distributed, i.e., in each cluster the variables are not correlated and have equal variance
* The clusters have equal (or similar) variance
* The clusters are of similar size

![Situations for which K-means fail to retrieve underlying clusters.](../../assets/img/lec07_kmeans_assumptions.png){#fig-kmeans_fail fig-align="center" fig-width=1000}

#### K-Means clustering in Python
Let us now apply K-means to the `mat` data matrix searching for 2 clusters. This can be easily achieved with the scikit-learn function `KMeans()`. While not necessary, it is a good idea to scale the variables, in order not to give the variables with larger scales too much importance (by dominating the Euclidean distances). Another way to look at it, is that the scaling reduces to some extent the problem of anisotropic clusters. In the following code, we first scale the data matrix with `StandardScaler()`. We also use the argument `n_init` of `KMeans()` to perform multiple random initializations. 

```{python}
#| fig-align: center
import sklearn
scaler = sklearn.preprocessing.StandardScaler()
X = pd.DataFrame(scaler.fit_transform(mat), index=mat.index, columns=mat.columns)
k = 2
clust_km = sklearn.cluster.KMeans(n_clusters=k, n_init=20)
clust_km.fit(X)
clust_km.labels_
```

We now update our heatmap with the results of the clustering. We make use of the `row_colors` argument of `sns.clustermap()` which generates color-coded row annotations on the left side of the heatmap. We furthermore order the rows of the data matrix by cluster.

```{python}
#| fig-align: 'center'
#| fig-cap: Heatmap with K-mean cluster annotation.
#| label: fig-kmeanheatmap
row_ann = pd.Series(["C"+str(s) for s in clust_km.labels_], index = mat.index)
unique_categories = np.unique(row_ann.values)
palette = sns.color_palette("husl", len(unique_categories))
color_mapping = dict(zip(unique_categories, palette))
row_col = row_ann.map(color_mapping)
sns.clustermap(X.iloc[np.argsort(clust_km.labels_)], row_colors=row_col,
               row_cluster=False, col_cluster=False, figsize=(4,4))
```

Cluster $C_1$ appears to group the heavy, powerful and gas-consuming cars and cluster $C_2$ the light, less powerful and more economic cars.

### Hierarchical clustering {#sec-hclust}

A major limitation of the K-means algorithm is that it relies on a predefined number of clusters. What if the interesting number of clusters is larger or smaller? Hierarchical clustering allows exploring multiple levels of clustering granularity at once by computing nested clusters. It results in a tree-based representation of the observations, called a dendrogram. @fig-hcexample shows an example of a hierarchical clustering using two variables only.

```{python}
#| echo: false
#| fig-align: center
sns.clustermap(X[["Horsepower","Weight"]], row_cluster=True, col_cluster=False, figsize=(4,4))
```


```{python}
#| echo: false
#| label: fig-hcexample
#| fig-align: center
tempdf = X[["Horsepower","Weight"]].copy()
tempdf["label"] = X.index
adjust_text_dict = {'arrowprops': {'arrowstyle': '-','color': 'grey'}}
(ggplot(tempdf, aes(x="Horsepower", y="Weight", label="label")) + geom_point()
  +  geom_text(adjust_text=adjust_text_dict) + mytheme + theme(figure_size=(4,4)))
```

Unlike with K-means, there is no objective function associated with hierarchical clustering. Hierarchical clustering is simply defined by how it operates.

We describe bottom-up (a.k.a. agglomerative) hierarchical clustering:

1. Initialization: Compute all the $n(n − 1)/2$ pairwise dissimilarities between the $n$ observations. Treat each observation as its own cluster. A typically dissimilarity measure is the Euclidean distance. Other dissimilarities can be used (1-correlation), Manhattan distance, etc.  

2. For $i=n, n-1, ..., 2$:

* Fuse the two clusters that are least dissimilar. The dissimilarity
between these two clusters indicates the height in the dendrogram at which the fusion should be placed. 

* Compute the new pairwise inter-cluster dissimilarities among the $i − 1$ remaining clusters using the linkage rule.

The *linkage rules* define dissimilarity between clusters. Here are four popular linkage rules:

* Complete: The dissimilarity between cluster A and cluster B is the largest dissimilarity between any element of A and any element of B.

* Single: The dissimilarity between cluster A and cluster B is the smallest dissimilarity between any element of A and any element of B. Single linkage can result in extended, trailing clusters in which single observations are fused one-at-a-time.

* Average:  The dissimilarity between cluster A and cluster B is the average dissimilarity between any element of A and any element of B.

* Centroid: The dissimilarity between cluster A and cluster B is the dissimilarity between the centroids (mean vector) of A and  B. Centroid linkage can result in undesirable inversions.


#### Hierarchical clustering in Python

In Python, Hierarchical clustering can be performed using either the `AgglomerativeClustering` class from scikit-learn, or the `linkage` function from scipy. In both cases, the clustering entails two steps. First, it computes the distance between observations (rows of a `DataFrame`) across variables (columns of a `DataFrame`). Here, the Euclidean distance between rows is computed by default. Alternatives include the Manhattan or Minkowski distance. As for K-means, it is recommended to work on scaled variables to not give too much importance to variables with large variance. We therefore compute the pairwise Euclidean distance to our scaled data matrix `X`. Second, we use the resulting Euclidean distance matrix as a dissimilarity matrix to perform Hierarchical clustering. The default linkage method is **single** for `linkage`, and **ward** ^[https://en.wikipedia.org/wiki/Ward%27s_method] for `Agglomerative Clustering`. Here we use average.

```{python}
from scipy.cluster.hierarchy import dendrogram, linkage, fcluster
hc_scipy = linkage(X, method='average')
hc_sklearn = sklearn.cluster.AgglomerativeClustering(linkage='average').fit_predict(X)
```

The results of hierarchical clustering can be shown using a dendrogram (i.e., a tree representation). Here, observations that are determined to be similar by the clustering algorithm are displayed close to each other in the `x`-axis. The height in the dendrogram at which two clusters are merged represents the distance between those two clusters.

```{python}
#| fig-align: 'center'
print(dendrogram(hc_scipy))
```

#### Clustermaps including hierarchical clustering

As illustrated before, the library `sns.clustermap` enables the easy creation of heatmaps. In the previous example, we set the parameters `row_cluster` and `col_cluster` to `False` to avoid the default computation of hierarchical clustering. If we want to include hierarchical clustering, we can simply set these parameters to `True` or let Python consider its default values. 

```{python}
#| fig-align: 'center'
sns.clustermap(X, row_cluster=True, col_cluster=False, figsize=(4,4))
```

Compared to K-means (@fig-kmeanheatmap), the hierarchical clustering shows useful different degrees of granularity of the clusters. We see the most similar cars grouping together (the Mercedes 230 and the Mercedes 240D). At the high level, the Duster 360 stands out as an outlier.

#### Cutting the tree

After having inspected the result of a hierarchical clustering, it is often interesting to define distinct clusters by cutting the dendrogram at a certain height.

Typically, one cuts dendrogram either at a given height, or in order to obtain a certain number of clusters. The functions `fcluster` from scipy and `AgglomerativeClustering` from scikit-learn support both options. Here is an example of cutting the dendrogram to get 3 clusters.

```{python}
hc_sklearn = sklearn.cluster.AgglomerativeClustering(n_clusters=3, linkage='average').fit(X)
hc_sklearn.labels_
```
```{python}
fcluster(hc_scipy, t=3, criterion="maxclust")
```

#### Differences between K-Means and hierarchical clustering

Both K-means and hierarchical clustering are well established and widely used. Here, we briefly state a few differences that may be considered when deciding which algorithm to apply in practice. 

The time complexity of K-Means clustering is linear, while that of hierarchical clustering is quadratic. This implies that hierarchical clustering can not handle extremely large datasets as efficiently as K-Means clustering. 

In K-Means clustering, we start with a random choice of centroids for each cluster. Hence, the results produced by the algorithm depend on the initialization. Therefore, the results might differ when running the algorithm multiple times. Hierarchical clustering outputs reproducible results.

Another difference is that K-Means clustering requires the number of clusters a priori. In contrast, the number of clusters we find appropriate in hierarchical clustering can be decided a posteriori by interpreting the dendrogram. 

### Comparing clusterings with the Rand index

Let us first visualize the outcome of K-means and of the hierarchical clustering cut for 3 clusters thanks to the row annotation option of `sns.clustermap`.  


```{python}
#| fig-align: 'center'
row_ann = pd.DataFrame({"kmeans":["C"+str(s) for s in clust_km.labels_], "hc":["C"+str(s) for s in hc_sklearn.labels_]}, index = X.index)
unique_categories = np.unique(row_ann.values)
palette = sns.color_palette("husl", len(unique_categories))
color_mapping = dict(zip(unique_categories, palette))
row_col = row_ann.map(lambda x: color_mapping[x])
sns.clustermap(X, row_colors=row_col, col_cluster=False, figsize=(5,5))
```

Comparing clustering results is a challenging task. When clustering into two groups, we could use evaluation measures from classification, which we will introduce later. Moving from two partitions of the data into arbitrarily many groups requires new ideas.

We remark that a partition is, in our context, the result from a clustering algorithm and, therefore, the divided dataset into clusters. Generally, two partitions (from different clustering algorithms) are considered to be similar when many pairs of points are grouped together in both partitions.

The Rand index is a measure of the similarity between two partitions. Formally, we introduce the following definitions:

* $S = \{o_1, \dots, o_n\}$ a set of $n$ elements (or observations)

* First partition $X = \{X_1, \dots, X_k\}$ of $S$ into $k$ sets

* Second partition $Y = \{Y_1, \dots, Y_l\}$ of $S$ into $l$ sets

* $a$ number of **pairs** of elements of $S$ that are **in the same set** in $X$ and in $Y$

* $b$ number of **pairs** of elements of $S$ that are **in different sets** in $X$ and in $Y$

* ${n}\choose{2}$ total number of pairs of elements of $S$

Then, the Rand index can be computed as
$$
R = \frac{a + b}{ {n}\choose 2 } 
$$

where  ${n}\choose{k}$ (reads "n choose 2"), the binomial coefficient for $k=2$, is the number of pairs of observations and is equal  to:

$$
{{n}\choose{2}} = \frac{(n-1) \cdot n }{2}. 
$$

#### Properties of the Rand index

By definition, the Rand index has values between 0 and 1, including them. A Rand index of 1 means that all pairs that are in the same cluster in the partition $X$ are also in the same cluster in the partition $Y$ **and** all pairs that are not in the same cluster in $X$ are also not in the same cluster in $Y$. Hence, the two partitions are identical with a Rand index of 1. In general, the higher the Rand index, the more similar are both partitions. 

#### Application of the Rand index

We can compute the Rand index between our k-means result and the cut of the hierarchical clustering for a given number of groups. See exercise sheet.

## Dimensionality reduction with PCA

A heatmap is a visualization method of choice for data matrices as long as rows and columns are visually resolved because it satisfies the two main data visualization principles, i.e.,: i. having a high data/ink ratio and ii. showing the data as raw as possible. 

However, beyond dimensions exceeding the thousands of variables, dimension reduction techniques are needed. The idea of dimension reduction is simple: if the dimension of our data $p$ is too large, let us consider instead a representation of lower dimension $q$ which retains much of the information of the dataset. 

For Principal Component Analysis (Pearson, 1901), this representation is *the projection of the data on the subspace of dimension $q$ that is closest to the data according to the sums of the squared Euclidean distances.*

Principal Component Analysis is not only the mother of all data reduction techniques but also still widely used. PCA enjoys several noticeable statistical properties which we will now look at.

### A minimal PCA: From 2D to 1D
To get an intuition of PCA, let us consider reducing a 2-dimensional dataset into a single dimension. This application has no visualization purposes but could help defining a linear combination of two variables into a aggregated score. For example, one can want to summarize the weight and horsepower of the cars into a single score.

#### Definition of the first principal component
Geometrically, we search for a line lying as close as possible to the data, in the sense of least squared Euclidean distances.


```{python}
#| fig-align: center
#| echo: false
# Seed and data
np.random.seed(2)
n = 20
mu = np.array([0.0, 0.0])
Sig = np.array([[1.0, 1.0],
                [1.0, 2.0]])
xy = np.random.multivariate_normal(mean=mu, cov=Sig, size=n)
xy = xy - xy.mean(axis=0)  # center (like scale(..., center=TRUE, scale=FALSE))
dt = pd.DataFrame({'x1': xy[:, 0], 'x2': xy[:, 1]})
m = np.abs(xy).max()
lims = [-m, m]
# PCA (first principal component)
pca = sklearn.decomposition.PCA(n_components=2).fit(xy)
pc1 = pca.components_[0]  # (vx, vy), unit vector
b1 = pc1[1] / pc1[0]      # slope of PC1 line through origin
# Arrow for u_vec (first PC direction) from the mean (0,0)
u_vec = pd.DataFrame({
    'x':   [mu[0]],
    'y':   [mu[1]],
    'xend':[mu[0] + pc1[0]],
    'yend':[mu[1] + pc1[1]]
})
# A point x and its projection onto PC1: p(x)
x_pt = np.array([2.5, 2.0])
y_coords = pca.components_.dot(x_pt - mu)   # coordinates in PC basis
xp1 = mu + y_coords[0] * pc1                # projection of x onto PC1
# Plot
(ggplot(dt, aes('x1', 'x2'))
    + geom_point(size=1)
    + labs(x=r'$x_1$', y=r'$x_2$')
    + scale_x_continuous(limits=lims)
    + scale_y_continuous(limits=lims)
    + geom_abline(intercept=0, slope=b1)
    + geom_segment(u_vec, aes(x='x', y='y', xend='xend', yend='yend'), color='darkred', size=1, arrow=arrow(length = 0.1))
    + annotate('text', x=-0.4, y=0.7, label='w', color='darkred')
    + annotate('text', x=x_pt[0]+0.1, y=x_pt[1]+0.1, label='x', color='black', va='bottom')
    + annotate('segment', x=x_pt[0], y=x_pt[1], xend=xp1[0], yend=xp1[1], color='black')
    + annotate('segment', x=x_pt[0], y=x_pt[1], xend=0, yend=0, color='black')
    + annotate('text', x=xp1[0]-0.7, y=xp1[1]+0.1, label='p(x)', color='black')
    + mytheme + theme(figure_size=(3,3))
)
```

We will assume all variables to be centered and admit the line passes therefore through the origin. Let us denote $\mathbf{w}$ a direction vector of the line of length 1.


The closest point of the observation vector $\mathbf{x_i}$ to the line is its orthogonal projection $p_{\top}(\mathbf{x_i})$ which is equal to the scalar product of the direction vector and the observation vector, times the direction vector:

$$
\begin{align}
p_{\top}(\mathbf{x_i}) &= (\mathbf{w}^\top\mathbf{x_i})\mathbf{w}
\end{align}
$$

Hence, we look for $\mathbf{w}$ such that: 

$$
\begin{align}
\min_{\mathbf{w}} & \sum_{i=1}^n || \mathbf{x} - (\mathbf{w}^\top\mathbf{x_i})\mathbf{w} ||^2 \\
\text{subject to} & ||\mathbf{w}||=1
\end{align}
$$ {#eq-pcamin}

There is typically a unique solution to this optimization problem (up to a sign). This direction vector $\mathbf{w}$ is called the *first principal component* (PC1) of the data.

#### PC1 maximizes the variance of the projected data
We defined PC1 with a minimization problem (@eq-pcamin). One can also see it as a maximization problem. To this end, consider the orthogonal triangle defined by an observation vector $\mathbf{x_i}$, its projection $p_{\top}(\mathbf{x_i})$, and the origin. Pythagoras' theorem implies that:

$$
\begin{align}
||\mathbf{x_i}||^2 = ||p_{\top}(\mathbf{x_i})||^2 +  || \mathbf{x} - p_{\top}(\mathbf{x_i}) ||^2
\end{align}
$$

Over the entire dataset, the sum of the $||\mathbf{x_i}||^2$ is constant independently of the choice of $\mathbf{w}$. Therefore minimization problem (@eq-pcamin) is equivalent to:

Over the entire dataset, the sum of the $||\mathbf{x_i}||^2$ is constant independently of the choice of $\mathbf{w}$. Therefore minimization problem Equation (@eq-pcamin) is equivalent to:

$$
\begin{align}
\max_{\mathbf{w}} & \sum_{i=1}^n ||p_{\top}(\mathbf{x_i})||^2 \\
\text{subject to} & ||\mathbf{w}||=1
\end{align}
$$

As we have centered the data, the origin is the mean of the data. Hence the sum of squared norms of the observation vectors is $n$ times their total variance. By linearity, the origin is also the mean of the projected data and thus:

$$
\sum_i||p_{\top}(\mathbf{x_i})||^2 = n \mathrm{Var}(p_{\top}(\mathbf{X}))
$$
Hence, one can equivalently consider that PC1 maximizes the variance of the projected data.


**Result** PC1 maximizes the variance of the projected data.

The *proportion of variance* captured by PC1 is defined as the ratio of the variance of the projected data over the total variance of the data. It is a proportion, hence lies between 0 and 1. The higher it is, the smaller the sum of squared distances, the closer the line is to the data. The proportion of variance hence quantifies how good our dimension reduction is.  


### PCA in higher dimensions
In the general case, with $p$ variables and $n$ observations, one searches for the $q$-dimensional plane that is closest to the data in terms of sums of squared Euclidean distances. This is also the $q$-dimensional plane that maximizes the variance of the projected data.

An important property relates principal components to the eigendecomposition of the covariance matrix.

The covariance matrix is $\frac{1}{n}\mathbf{X}^{\top}\mathbf{X}$. It is a symmetric positive matrix. We denote $\mathbf{w_1},...,\mathbf{w_j},...$ its eigenvectors ordered by decreasing eigenvalues $\lambda_1 >...> \lambda_j>...$. 

**Result**. The PCA $q$-dimensional plane, i.e., the $q$-dimensional plane that is closest to the data in terms of sums of squared Euclidean distances, is the plane spanned by the first $q$ eigenvectors of the covariance matrix.

**Result**. The variance explained by the PCA $q$-dimensional plane equals to the sum of the $q$ first eigenvalues of the covariance matrix.  

See @bishop2007 for proofs.

These results have several implications:

* The PCA planes are nested: the PCA 2D-plane contains PC1, the PCA 3D-plane contains the PCA 2D-plane, etc.

* We call second principal component (PC2) the second eigenvector of the covariance matrix, etc.

* The principal components are linearly uncorrelated. This is because the eigenvectors of a positive matrix are orthogonal to each other. If $n>p$ (more observation than variables) the PCs form an orthonormal basis. 

A 3D illustration of PCA is available at [https://setosa.io/ev/principal-component-analysis/].

### PCA in Python

PCA can be easily performed in Python by using the scikit-learn function `PCA()`.  

In most applications, scaling the data beforehand is important. Because PCA is based on minimizing squared Euclidean distances, scaling allows to not give too much importance to variables living on larger scales than the other ones. Be careful: `PCA` always centers data to 0, but it does **NOT** scale the variables to unit variance.

In the following examples, we perform PCA on our `mat` dataset. We run `StandardScaler` to scale the data before the PCA.

```{python}
X = sklearn.preprocessing.StandardScaler().fit_transform(mat)
pca_res = sklearn.decomposition.PCA().fit(X) 
```

The output can be stored in `pca_res`, which contains information about the values of each sample in terms of the principal components (`pca.transform(X)`), variance (`pca.explained_variance_`) of each principal component, and the relationship between the initial variables and the principal components (i.e. loadings, `pca.components_`).

An overview of the PCA result can be obtained from the object attributes. We remark that the cumulative proportion is always equal to one for the last principal component.

```{python}
sum_df = pd.DataFrame({
    'Variance': pca_res.explained_variance_,
    'Proportion of Variance': pca_res.explained_variance_ratio_,
    'Cumulative Proportion': np.cumsum(pca_res.explained_variance_ratio_)
}, index=[f'PC{i+1}' for i in range(pca_res.n_components_)])
sum_df
```

In this example, the first principal component explains 66.7% of the total variance and the second one 18.2%.  So, just `PC1` and `PC2` can explain approximately 84.9% of the total variance.

### Plotting  PCA results in Python

Plotting the results of  PCA is particularly important. The so-called **scree plot** is a good first step for visualizing the PCA output, since it may be used as a diagnostic tool to check whether the PCA worked well on the selected dataset or not.  

```{python}
#| fig-align: center
(ggplot(sum_df, aes('sum_df.index', 'Variance', group=1)) + geom_line()
+ geom_point() + mytheme + theme(figure_size=(4,3)))
```

The scree plot shows the variance in each projected direction. The y-axis contains the eigenvalues, which essentially stand for the amount of variation. We can use a scree plot to select the principal components to keep. If the scree plot has an 'elbow' shape, it can be used to decide how many principal components to use for further analysis. For example, we may achieve dimensionality reduction by transforming the original four dimensional data (first four variables of `mtcars`) to a two-dimensional space by using the first two principal components.

A variant of the scree plot can be considered by plotting the proportion of the total variance for every principal component. 

```{python}
#| fig-align: center
(ggplot(sum_df, aes('sum_df.index', 'Proportion of Variance', group=1)) 
+ geom_line() + geom_point() + mytheme + theme(figure_size=(4,3)))
```

We can access the projection of the original data on the principal components by using the method `.transform()`. A scatterplot shows the projection of the data on the first two principal components.

```{python}
#| fig-align: center
scores_df = pd.DataFrame(pca_res.transform(X),\
  columns = [f'PC{i+1}' for i in range(pca_res.n_components_)], \
    index=mat.index)
p = (ggplot(scores_df, aes('PC1', 'PC2')) + geom_point()
    + geom_text(aes(label='scores_df.index'), adjust_text=adjust_text_dict) + mytheme)
p
```

The **biplot** shows the projection of the data on the first two principal components. It includes both the position of each sample in terms of `PC1` and `PC2` and also shows how the initial variables map onto this. The correlation between variables can be derived from the angle between the vectors. Here, a small angle is related to a high correlation.
The sign of the variable loadings in the new dimensional space indicates their contribution to the PCs. Here `Miles per Gallon` correlates positively with PC1, while the other three variables contribute negatively to the first component.

```{python}
#| fig-align: center
scale_x = scores_df['PC1'].std() * 3 # Scale loadings to fit the space
scale_y = scores_df['PC2'].std() * 3
load_df = pd.DataFrame({'xstart': 0.0, 'ystart': 0.0, 'label': mat.columns,
    'xend': pca_res.components_.T[:,0] * scale_x,
    'yend': pca_res.components_.T[:,1] * scale_y})
(p + geom_segment(load_df, aes('xstart', 'ystart', xend='xend', yend='yend'), \
  color='tomato', arrow=arrow(length=0.1))
+ geom_text(load_df, aes('xend', 'yend', label='label'), color='tomato', size=9))
```

### PCA summary
PCA is a statistical procedure that uses an orthogonal transformation to convert a set of possibly correlated variables into a set of linearly uncorrelated variables, which are denoted as principal components.

Each principal component explains a fraction of the total variation in the dataset. The first principal component has the largest possible variance. Respectively, the second principal component has the second-largest possible variance.

In this manner, PCA aims to reduce the number of variables, while preserving as much information from the original dataset as possible. High-dimensional data is often visualized by plotting the first two principal components after performing PCA. 

### Nonlinear dimension reduction
One limitation of PCA is that it is restricted to linear transformation of the data. What if the data lies closer to a parabola rather than a straight line? There are many non-linear alternatives to PCA including Independent Component Analysis, kernel PCA, t-SNE, UMAP. Details of these techniques are beyond the scope of this lecture. However, as long as one uses these techniques as visualization and exploratory tools rather than for making any claim on the data, a profound understanding of their theory is not necessary. 

We illustrate here with one example of a PCA and a UMAP representation of same single-cell gene expression matrix of mouse. The input matrix has 15,604 rows (single cells) and 1,951 columns (genes) and comes for the Tabula muris project ^[https://tabula-muris.ds.czbiohub.org/]. 

[PCA on mouse single-cell transcriptome data. Source: Laura Martens, TUM](../../assets/img/lec05_single_cell_pca.png){fig-width=600 fig-align="center"}

[UMAP (non-linear dimension reduction) on mouse single-cell transcriptome data. Source: Laura Martens, TUM](../../assets/img/lec05_single_cell_umap.png){fig-width=600 fig-align="center"}


## Discussion
* Clustering and dimension reduction techniques belong to the family of unsupervised learning methods. Unlike supervised learning methods (e.g. regression, classification) unsupervised learning methods shall discover patterns in the data without being guided by some ground truth.

* There is no "right" clustering, or "right" subspace in real-life datasets

* Clustering and dimension reduction techniques are exploratory tools meant to help deriving some hypotheses

* These hypotheses are then best tested on independent data

## Summary 

By now, you should be able to:

* plot data matrices as pretty heatmaps
* understand the effects of centering and scaling
* describe and apply k-means clustering
* describe and apply agglomerative hierarchical clustering
* PCA:
  * definition
  * property: maximize variance
  * property: uncorrelated components
  * compute and plot a PCA representation in R
  * compute the proportion of explained variance in R
  
  
## Resources
G. James, D. Witten, T. Hastie and R. Tibshirani. An Introduction to Statistical Learning with Applications in R.
Book and R code available at:
https://www.statlearning.com/

Advanced (PCA proofs):
C. Bishop, Pattern Recognition and Machine Learning. https://www.microsoft.com/en-us/research/people/cmbishop/prml-book/
